import os
import sys
import time
import random
import inspect
import filetools
import numpy as np

# Locations
HERE = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
BASE = os.path.join(HERE, "..", "..")
ROOT = os.path.join(BASE, "..")
PLATFORM = os.path.join(ROOT, "nanobot", "software")
RUN = os.path.join(ROOT, "nanobot_run")
DATA = os.path.join(RUN, "data", "genetic")

sys.path.append(PLATFORM)

from .genetic import GA
import utils.json_utils as json
import operations.constants.filenames as fn
import operations.constants.info_keys as keys

class Creator(object):
    """
    Class for creating generations to be used with the GA algorithm
    Creates a generation of experiments to be conducted

    Args:
        info (Dict): Info from the platform's info file
        params (Dict): Parameters for the algorithm
    """
    def __init__(self, info):
        self.info = info
        self.params = info["GA"]
        self.xp_path = self.generate_xp_folder()
        self.set_random_seed()
        self.algorithm = GA(**self.params["params"])

        # Average fitnesses for graph
        self.average_fitnesses = []


    def set_random_seed(self):
        """
        Sets the random seed from the info file
        Helps to seed the algorithm
        """
        random.seed(self.info[keys.SEED])
        np.random.seed(int(self.info[keys.SEED]))


    def generate_xp_folder(self):
        """
        Creates a root folder for the experiment
        """
        path = os.path.join(DATA, self.info[keys.TITLE], str(self.info[keys.SEED]))
        filetools.ensure_dir(path)

        return path


    def create_population(self):
        """
        Creates a new population of values for a generation

        Returns:
            pop (List): List of values for the generation
        """
        return self.algorithm.get_next_population()


    def convert_pop_to_dict(self, pop):
        """
        Converts a population of values into a dictionary for use with the platform's pumps

        Args:
            pop (List): List of values generated by the algorithm

        Returns:
            ratio (Dict): Dictionary containing the pump names and values form the population
        """

        static, varied = self.params["static_reagents"], self.params["varied_reagents"]

        varied_dict = {reagent: vol for reagent, vol in zip(varied, pop)}

        return {**varied_dict, **static}


    def create_single_experiment(self, gen_folder: str):
        """Creates a single experiment file

        Args:
            gen_folder (str): Generation folder
        """

        single_xp = {
            "silver": 2.0475021741687085,
            "surfactant": 4.070063550325937,
            "gold": 2.762982287687803,
            "reductant": 1.0594519878175512,
            "seeds": 0.06
        }

        xp_folder_name = "ideal_synthesis"
        xp_folder = os.path.join(gen_folder, xp_folder_name)
        filetools.ensure_dir(xp_folder)
        params = os.path.join(xp_folder, fn.PARAMS_FILE)
        json.write(single_xp, params)


    def create_generation(self, n_gen):
        """
        Creates a generation folder, populated with experiments
        Algorithm generates parameters for each experiment
        Random parameters at first then algorithmically chosen onces thereafter

        Args:
            n_gen (int): Current generation number
        """
        # Creates a population of experiments for the generation
        population = self.create_population()
        # Creates the folder for the generation
        gen_number = filetools.generate_n_digit_name(n_gen)
        gen_folder = os.path.join(self.xp_path, gen_number)
        filetools.ensure_dir(gen_folder)

        print("Creating generation: {}".format(os.path.relpath(gen_folder)))

        # Iterates through the population, creating a folder and params file for each xp
        for pos, _ in enumerate(population):
            # Creates the xp folder
            xp_folder_name = filetools.generate_n_digit_name(pos)
            xp_folder = os.path.join(gen_folder, xp_folder_name)
            filetools.ensure_dir(xp_folder)

            # Converts the population for this XP into a dictionary
            params = self.convert_pop_to_dict(population[pos])
            params_file = os.path.join(xp_folder, fn.PARAMS_FILE)
            xp_log = os.path.join(xp_folder, fn.XP_LOG)

            # Checks if a parameter file exists and checks the values for this seed number match
            if os.path.exists(xp_log):
                params = json.read(xp_log)["raw_params"]
                json.write(params, params_file)
            else:
                json.write(params, params_file)

        self.watch_for_fitness(gen_folder)


    def watch_for_fitness(self, path):
        """
        Watches a specific folder for a fitness.json file
        Updates the algorithm with new fitnesses once found
        Appends the median fitnesses to the average

        Args:
            path (str): Folder to watch
        """

        fitness_path = os.path.join(path, fn.FITNESS_FILE)
        print("Waiting for fitness file in {}.".format(os.path.relpath(path)))

        # Wait for the fitness file to be created
        while not os.path.exists(fitness_path):
            time.sleep(0.5)

        # Get the fitnesses and update the algorithm
        fitness_data = json.read(fitness_path)
        fitnesses = fitness_data["fitness"]
        self.algorithm.set_fitness_value(fitnesses)

        # Append the average of the fitnesses to the overall average
        avg = np.median(fitnesses)
        self.average_fitnesses.append(avg)


    def plot_fitness_curve(self, path):
        """
        Plots the median firness of the entire experiment

        Args:
            path (str): Root location of the XP
        """
        import matplotlib.pyplot as plt
        print("Plotting average fitness curve of {}.".format(path))

        title = path.split("/")[-1:]
        plt.title("Median fitness of XP {}".format(title))
        plt.xlabel("Generations")
        plt.ylabel("Fitness")
        plt.plot(self.average_fitnesses)
        fig_name = str(self.info[keys.SEED]) + ".png"
        save_path = os.path.join(path, fig_name)
        plt.savefig(save_path)


    def initialise(self):
        """
        Initialises the Creator to run for the total number of generations
        """
        total_generations = self.info[keys.GENS]
        for gen in range(total_generations):
            self.create_generation(gen)
        self.plot_fitness_curve(self.xp_path)
